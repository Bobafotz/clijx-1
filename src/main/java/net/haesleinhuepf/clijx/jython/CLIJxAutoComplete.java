package net.haesleinhuepf.clijx.jython;
import org.fife.ui.autocomplete.BasicCompletion;
import net.haesleinhuepf.clijx.jython.ScriptingAutoCompleteProvider;
import java.util.ArrayList;// this is generated code. See src/test/java/net/haesleinhuepf/clijx/codegenerator for details
class CLIJxAutoComplete {
   
   public static ArrayList<BasicCompletion> getCompletions(final ScriptingAutoCompleteProvider provider) {
       ArrayList<BasicCompletion> list = new ArrayList<BasicCompletion>();
       String headline;
       String description;
       headline = "clijx.absolute(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>absolute</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.absoluteDifference(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>absoluteDifference</b><br><br>Determines the absolute difference pixel by pixel between two images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.absoluteInplace(ClearCLBuffer source_destination)";
       description = "<b>absoluteInplace</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Deprecated: Use absolute() instead.<br><br>Parameters:<br>ClearCLBuffer source_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>addImageAndScalar</b><br><br>Adds a scalar value s to all pixels x of a given image X.<br><br><pre>f(x, s) = x + s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImages(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination)";
       description = "<b>addImages</b><br><br>Calculates the sum of pairs of pixels x and y of two images X and Y.<br><br><pre>f(x, y) = x + y</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImagesWeighted(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2)";
       description = "<b>addImagesWeighted</b><br><br>Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.<br><br><pre>f(x, y, a, b) = x * a + y * b</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.adjacencyMatrixToTouchMatrix(ClearCLBuffer adjacency_matrix, ClearCLBuffer touch_matrix)";
       description = "<b>adjacencyMatrixToTouchMatrix</b><br><br>Converts a adjacency matrix in a touch matrix<br><br>Parameters:<br>ClearCLBuffer adjacency_matrix, ClearCLBuffer touch_matrix";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform(null)";
       description = "<b>affineTransform</b><br><br>Applies an affine transform to a 3D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform2D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform2D</b><br><br>Applies an affine transform to a 2D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform3D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform3D</b><br><br>Applies an affine transform to a 3D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyAutoContextWekaModelWithOptions(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3, String arg4, int arg5)";
       description = "<b>applyAutoContextWekaModelWithOptions</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField</b><br><br>Deforms an image according to distances provided in the given vector images.<br><br> It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField2D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField2D</b><br><br>Deforms an image according to distances provided in the given vector images.<br><br> It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField3D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination)";
       description = "<b>applyVectorField3D</b><br><br>Deforms an image stack according to distances provided in the given vector image stacks.<br><br>It is recommended to use 32-bit image stacks for input, output and vector image stacks. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename)";
       description = "<b>applyWekaModel</b><br><br>Applies a Weka model using functionality of Fijis Trainable Weka Segmentation plugin. <br><br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and applies a pre-trained a Weka model. Take care that the feature stack has been generated in the sameway as for training the model!<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyWekaToTable(ResultsTable arg1, String arg2, String arg3)";
       description = "<b>applyWekaToTable</b><br><br>Applies a Weka model using functionality of Fijis Trainable Weka Segmentation plugin. <br><br>It takes a Results Table, sorts its columns by name alphabetically and uses it as extracted features (rows correspond to feature vectors) and applies a pre-trained a Weka model. Take care that the table has been generated in the sameway as for training the model!<br><br>Parameters:<br>ResultsTable arg1, String arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.argMaximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max)";
       description = "<b>argMaximumZProjection</b><br><br>Determines the maximum projection of an image stack along Z.<br><br>Furthermore, another 2D image is generated with pixels containing the z-index where the maximum was found (zero based).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThreshold(ClearCLBuffer input, ClearCLBuffer destination, String method)";
       description = "<b>automaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br> Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThresholdInplace(ClearCLBuffer input_and_destination, String method)";
       description = "<b>automaticThresholdInplace</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Deprecated: Use threshold* instead.<br><br>Parameters:<br>ClearCLBuffer input_and_destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>averageDistanceOfClosestPoints</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>averageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids and replaces every label with the average distance to the n closest neighboring labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfNClosestPoints(ClearCLBuffer distance_matrix, ClearCLBuffer distance_list_destination, Integer nClosestPointsTofind)";
       description = "<b>averageDistanceOfNClosestPoints</b><br><br>Determines the average of the n closest points for every point in a distance matrix.<br><br>This corresponds to the average of the n minimum values (rows) for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer distance_list_destination, Integer nClosestPointsTofind";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfNFarOffPoints(ClearCLBuffer distance_matrix, ClearCLBuffer distance+_list_destination, Integer nFarOffPointsTofind)";
       description = "<b>averageDistanceOfNFarOffPoints</b><br><br>Determines the average of the n far off (most distant) points for every point in a distance matrix.<br><br>This corresponds to the average of the n maximum values (rows) for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer distance+_list_destination, Integer nFarOffPointsTofind";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the average distance of touching neighbors <br> for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>averageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the average distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bilateral(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ, Float sigma_intensity, Float sigma_space)";
       description = "<b>bilateral</b><br><br>Applies a bilateral filter using a box neighborhood with sigma weights for space and intensity to the input image.<br><br>Deprecated: Use SimpleITK bilateral() instead.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ, Float sigma_intensity, Float sigma_space";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryAnd(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryAnd</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary AND operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryEdgeDetection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryEdgeDetection</b><br><br>Determines pixels/voxels which are on the surface of binary objects and sets only them to 1 in the <br>destination image. All other pixels are set to 0.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryFillHoles(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryFillHoles</b><br><br>Fills holes (pixels with value 0 surrounded by pixels with value 1) in a binary image.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryFillHolesSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryFillHolesSliceBySlice</b><br><br>Fills holes (pixels with value 0 surrounded by pixels with value 1) in a binary image stack slice by slice.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryIntersection(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryIntersection</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary intersection operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryNot(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryNot</b><br><br>Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values<br>x using the binary NOT operator !<br><br>All pixel values except 0 in the input image are interpreted as 1.<br><br><pre>f(x) = !x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary OR operator |.<br><br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binarySubtract(ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination)";
       description = "<b>binarySubtract</b><br><br>Subtracts one binary image from another.<br><br>Parameters:<br>ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryUnion(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryUnion</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary union operator |.<br><br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryWekaPixelClassifier(ClearCLBuffer input, ClearCLBuffer destination, String features, String modelfilename)";
       description = "<b>binaryWekaPixelClassifier</b><br><br>Applies a pre-trained CLIJx-Weka model to a 2D image. <br><br>You can train your own model using menu Plugins > Segmentation > CLIJx Binary Weka Pixel ClassifierMake sure that the handed over feature list is the same used while training the model.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, String features, String modelfilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryXOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryXOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary operators AND &, OR | and NOT ! implementing the XOR operator.<br><br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = (x & !y) | (!x & y)</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>DEPRECATED: This method is <b>deprecated</b>. Use gaussianBlur2D instead.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>DEPRECATED: This method is <b>deprecated</b>. Use gaussianBlur2D instead.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>blur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>DEPRECATED: This method is <b>deprecated</b>. Use gaussianBlur3D instead.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blurSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blurSliceBySlice</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The Gaussian blur is applied slice by slice in 2D.<br><br>DEPRECATED: This method is <b>deprecated</b>. Use gaussianBlur3D instead.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatBox</b><br><br>Apply a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatSphere</b><br><br>Applies a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.boundingBox(ClearCLBuffer source)";
       description = "<b>boundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. <br><br>If called from macro, the positions will be stored in a new row of ImageJs Results table in the columns 'BoundingBoxX', 'BoundingBoxY', 'BoundingBoxZ', 'BoundingBoxWidth', 'BoundingBoxHeight' 'BoundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.captureWebcamImage(ClearCLBuffer destination, Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight)";
       description = "<b>captureWebcamImage</b><br><br>Acquires an image (in fact an RGB image stack with three slices) of given size using a webcam. <br><br>It uses the webcam-capture library by Bartosz Firyn.https://github.com/sarxos/webcam-capture<br><br>Parameters:<br>ClearCLBuffer destination, Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centerOfMass(ClearCLBuffer source)";
       description = "<b>centerOfMass</b><br><br>Determines the center of mass of an image or image stack. <br><br>It writes the result in the results table<br>in the columns MassX, MassY and MassZ.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centroidsOfBackgroundAndLabels(ClearCLBuffer source, ClearCLBuffer pointlist_destination)";
       description = "<b>centroidsOfBackgroundAndLabels</b><br><br>Determines the centroids of the background and all labels in a label image or image stack. <br><br>It writes the resulting  coordinates in a pointlist image. Depending on the dimensionality d of the labelmap and the number  of labels n, the pointlist image will have n*d pixels.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer pointlist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centroidsOfLabels(ClearCLBuffer source, ClearCLBuffer pointlist_destination)";
       description = "<b>centroidsOfLabels</b><br><br>Determines the centroids of all labels in a label image or image stack. <br><br>It writes the resulting  coordinates in a pointlist image. Depending on the dimensionality d of the labelmap and the number  of labels n, the pointlist image will have n*d pixels.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer pointlist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.clInfo(null)";
       description = "<b>clInfo</b><br><br>Outputs information about available OpenCL devices.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.clear(null)";
       description = "<b>clear</b><br><br>Resets the GPUs memory by deleting all cached images.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closeIndexGapsInLabelMap(ClearCLBuffer labeling_input, ClearCLImageInterface labeling_destination)";
       description = "<b>closeIndexGapsInLabelMap</b><br><br>Analyses a label map and if there are gaps in the indexing (e.g. label 5 is not present) all <br>subsequent labels will be relabelled. <br><br>Thus, afterwards number of labels and maximum label index are equal.<br>This operation is mostly performed on the CPU.<br><br>Parameters:<br>ClearCLBuffer labeling_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions)";
       description = "<b>closingBox</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions)";
       description = "<b>closingDiamond</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequently.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.combineHorizontally(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>combineHorizontally</b><br><br>Combines two images or stacks in X.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.combineVertically(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>combineVertically</b><br><br>Combines two images or stacks in Y.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.concatenateStacks(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>concatenateStacks</b><br><br>Concatenates two stacks in Z.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabeling(ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination)";
       description = "<b>connectedComponentsLabeling</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>DEPRECATED: This method is <b>deprecated</b>. Use ConnectedComponentsLabellingBox (or Diamond) instead.<br><br>Parameters:<br>ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingBox(ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination)";
       description = "<b>connectedComponentsLabelingBox</b><br><br>Performs connected components analysis inspecting the box neighborhood of every pixel to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingDiamond(ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination)";
       description = "<b>connectedComponentsLabelingDiamond</b><br><br>Performs connected components analysis inspecting the diamond neighborhood of every pixel to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingInplace(ClearCLBuffer binary_source_labeling_destination)";
       description = "<b>connectedComponentsLabelingInplace</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Deprecated: Use connectedComponentsLabelingBox() instead.<br><br>Parameters:<br>ClearCLBuffer binary_source_labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.convertFloat(null)";
       description = "<b>convertFloat</b><br><br>Convert the input image to a float image with 32 bits per pixel.<br><br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.convertRGBStackToGraySlice(ClearCLBuffer stack_source, ClearCLBuffer slice_destination)";
       description = "<b>convertRGBStackToGraySlice</b><br><br>Converts a three channel image (stack with three slices) to a single channel image (2D image) by multiplying with factors 0.299, 0.587, 0.114.<br><br>Parameters:<br>ClearCLBuffer stack_source, ClearCLBuffer slice_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.convertUInt16(null)";
       description = "<b>convertUInt16</b><br><br>Convert the input image to a unsigned integer image with 16 bits per pixel.<br><br>Pixel values are copied as they are. Use multiplyImageWithScalar in order to scalepixel values when reducing bit-depth to prevent cutting-off intensity ranges.<br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.convertUInt8(null)";
       description = "<b>convertUInt8</b><br><br>Convert the input image to a unsigned integer image with 8 bits per pixel.<br><br>Pixel values are copied as they are. Use multiplyImageWithScalar in order to scalepixel values when reducing bit-depth to prevent cutting-off intensity ranges.<br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.convolve(ClearCLBuffer source, ClearCLBuffer convolution_kernel, ClearCLBuffer destination)";
       description = "<b>convolve</b><br><br>Convolve the image with a given kernel image.<br><br>It is recommended that the kernel image has an odd size in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer convolution_kernel, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copy(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>copy</b><br><br>Copies an image.<br><br><pre>f(x) = x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex)";
       description = "<b>copySlice</b><br><br>This method has two purposes: <br>It copies a 2D image to a given slice z position in a 3D image stack or <br>It copies a given slice at position z in an image stack to a 2D image.<br><br>The first case is only available via ImageJ macro. If you are using it, it is recommended that the <br>target 3D image already pre-exists in GPU memory before calling this method. Otherwise, CLIJ create <br>the image stack with z planes.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels(ClearCLBuffer source)";
       description = "<b>countNonZeroPixels</b><br><br>Determines the number of all pixels in a given image which are not equal to 0. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'CountNonZero'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels2DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixels2DSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel. <br><br>Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsLocallySliceBySlice(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocallySliceBySlice</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsSliceBySliceSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixelsSliceBySliceSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel slice by slice in a stack. <br><br> It puts the resulting number in the destination image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxels3DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>countNonZeroVoxels3DSphere</b><br><br>Counts non-zero voxels in a sphere around every voxel. <br><br>Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>countNonZeroVoxelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countTouchingNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination)";
       description = "<b>countTouchingNeighbors</b><br><br>Takes a touch matrix as input and delivers a vector with number of touching neighbors per label as a vector.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.create2D(null)";
       description = "<b>create2D</b><br><br>Allocated memory for a new 2D image in the GPU memory. <br><br>BitDepth must be 8 (unsigned byte), 16 (unsigned short) or 32 (float).<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.create3D(null)";
       description = "<b>create3D</b><br><br>Allocated memory for a new 3D image in the GPU memory. <br><br>BitDepth must be 8 (unsigned byte), 16 (unsigned short) or 32 (float).<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop</b><br><br>Crops a given rectangle out of a given image. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop2D</b><br><br>Crops a given rectangle out of a given image. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>crop3D</b><br><br>Crops a given sub-stack out of a given image stack. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crossCorrelation(ClearCLBuffer input1, ClearCLBuffer meanInput1, ClearCLBuffer input2, ClearCLBuffer meanInput2, ClearCLBuffer destination, Integer radius, Integer deltaPos, Integer dimension)";
       description = "<b>crossCorrelation</b><br><br>Performs cross correlation analysis between two images. <br><br>The second image is shifted by deltaPos in the given dimension. The cross correlation coefficient is calculated for each pixel in a range around the given pixel with given radius in the given dimension. Together with the original images it is recommended to hand over mean filtered images using the same radius.  <br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer meanInput1, ClearCLBuffer input2, ClearCLBuffer meanInput2, ClearCLBuffer destination, Integer radius, Integer deltaPos, Integer dimension";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.customOperation(String arg1, String arg2, HashMap arg3)";
       description = "<b>customOperation</b><br><br>Executes a custom operation wirtten in OpenCL on a custom list of images. <br><br>All images must be created before calling this method. Image parameters should be handed over as an array with parameter names and image names alternating, e.g.<br><br>Ext.CLIJ2_customOperation(..., ..., newArray(&quot;image1&quot;, &quot;blobs.gif&quot;, &quot;image2&quot;, &quot;Processed_blobs.gif&quot;))<br><br>In the custom code, you can use the predefined variables x, y and z to deal with coordinates.<br>You can for example use it to access pixel intensities like this:<br><br>float value = READ_IMAGE(image, sampler, POS_image_INSTANCE(x, y, z, 0)).x;<br>WRITE_IMAGE(image, POS_image_INSTANCE(x, y, z, 0), CONVERT_image_PIXEL_TYPE(value));<br><br>Note: replace `image` with the given image parameter name. You can furthermore use custom function to organise code in the global_code parameter. In OpenCL they may look like this:<br><br>inline float sum(float a, float b) {<br>    return a + b;<br>}<br><br><br>Parameters:<br>String arg1, String arg2, HashMap arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.cylinderTransform(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_z)";
       description = "<b>cylinderTransform</b><br><br>Applies a cylinder transform to an image stack assuming the center line goes in Y direction in the center of the stack.<br><br>This transforms an image stack from an XYZ coordinate system to a AYD coordinate system with <br>A the angle around the center line, <br>Y the original Y coordinate and <br>D, the distance from the center.<br><br>Thus, going in virtual Z direction (actually D) in the resulting stack, you go from the center to theperiphery.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.deformableRegistration2D(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination, Integer maxDeltaX, Integer maxDeltaY)";
       description = "<b>deformableRegistration2D</b><br><br>Applies particle image velocimetry to two images and registers them afterwards by warping input image 2 with a smoothed vector field.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination, Integer maxDeltaX, Integer maxDeltaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.depthColorProjection(ClearCLImageInterface source, ClearCLBuffer lookup_table, ClearCLBuffer destination_max, Float min_display_intensity, Float max_display_intensity)";
       description = "<b>depthColorProjection</b><br><br>Determines a maximum projection of an image stack and does a color coding of the determined arg Z (position of the found maximum). <br><br>Second parameter is a Lookup-Table in the form of an 8-bit image stack 255 pixels wide, 1 pixel high with 3 planes representing red, green and blue intensities.<br>Resulting image is a 3D image with three Z-planes representing red, green and blue channels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLBuffer lookup_table, ClearCLBuffer destination_max, Float min_display_intensity, Float max_display_intensity";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectAndLabelMaxima(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>detectAndLabelMaxima</b><br><br>Determines maximum regions in a Gaussian blurred version of the original image.<br><br>The regions do not not necessarily have to be single pixels. <br>It is also possible to invert the image before determining the maxima.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Boolean arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectLabelEdges(ClearCLImageInterface label_map, ClearCLBuffer edge_image_destination)";
       description = "<b>detectLabelEdges</b><br><br>Takes a labelmap and returns an image where all pixels on label edges are set to 1 and all other pixels to 0.<br><br>Parameters:<br>ClearCLImageInterface label_map, ClearCLBuffer edge_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaxima2DBox(null)";
       description = "<b>detectMaxima2DBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaxima3DBox(null)";
       description = "<b>detectMaxima3DBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMaximaBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>detectMaximaSliceBySliceBox</b><br><br>Detects local maxima in a given square neighborhood of an input image stack. <br><br>The input image stack is processed slice by slice. Pixels in the resulting image are set to 1 if <br>there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinima2DBox(null)";
       description = "<b>detectMinima2DBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinima3DBox(null)";
       description = "<b>detectMinima3DBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMinimaBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer RadiusY)";
       description = "<b>detectMinimaSliceBySliceBox</b><br><br>Detects local minima in a given square neighborhood of an input image stack. <br><br>The input image stack is processed slice by slice. Pixels in the resulting image are set to 1 if <br>there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer RadiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian2D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian2D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian3D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussian3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussianInplace3D(ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussianInplace3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Deprecated: Use differenceOfGaussian3D instead.<br><br>Parameters:<br>ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMap(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>distanceMap</b><br><br>Generates a distance map from a binary image. <br><br>Pixels with non-zero value in the binary image are set to a number representing the distance to the closest zero-value pixel.<br><br>Note: This is not a distance matrix. See generateDistanceMatrix for details.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximum_distance)";
       description = "<b>distanceMatrixToMesh</b><br><br>Generates a mesh from a distance matric and a list of point coordinates.<br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a distance matrix of size n*n to draw lines from all points to points if the corresponding pixel in the distance matrix is smaller than a given distance threshold.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximum_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.divideByGaussianBackground(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>divideByGaussianBackground</b><br><br>Applies Gaussian blur to the input image and divides the original by the result.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.divideImages(ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination)";
       description = "<b>divideImages</b><br><br>Divides two images X and Y by each other pixel wise. <br><br><pre>f(x, y) = x / y</pre><br><br>Parameters:<br>ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample2D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ)";
       description = "<b>downsample3D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsampleSliceBySliceHalfMedian(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>downsampleSliceBySliceHalfMedian</b><br><br>Scales an image using scaling factors 0.5 for X and Y dimensions. The Z dimension stays untouched. <br><br>Thus, each slice is processed separately.<br>The median method is applied. Thus, each pixel value in the destination image equals to the median of<br>four corresponding pixels in the source image.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawBox(ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value)";
       description = "<b>drawBox</b><br><br>Draws a box at a given start point with given size. <br>All pixels other than in the box are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawDistanceMeshBetweenTouchingLabels(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>drawDistanceMeshBetweenTouchingLabels</b><br><br>Starting from a label map, draw lines between touching neighbors resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. The intensity of the lines <br>corresponds to the distance between these labels (in pixels or voxels).<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawLine(ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value)";
       description = "<b>drawLine</b><br><br>Draws a line between two points with a given thickness. <br><br>All pixels other than on the line are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawMeshBetweenTouchingLabels(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>drawMeshBetweenTouchingLabels</b><br><br>Starting from a label map, draw lines between touching neighbors resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. <br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawSphere(ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value)";
       description = "<b>drawSphere</b><br><br>Draws a sphere around a given point with given radii in x, y and z (if 3D). <br><br> All pixels other than in the sphere are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawTouchCountMeshBetweenTouchingLabels(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>drawTouchCountMeshBetweenTouchingLabels</b><br><br>Starting from a label map, draw lines between touching neighbors resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. The intensity of the lines <br>corresponds to the touch count between these labels.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawTwoValueLine(ClearCLBuffer destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value1, Float destination0)";
       description = "<b>drawTwoValueLine</b><br><br>Draws a line between two points with a given thickness. <br><br>Pixels close to point 1 are set to value1. Pixels closer to point 2 are set to value2 All pixels other than on the line are untouched. Consider using clij.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLBuffer destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value1, Float destination0";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.driftCorrectionByCenterOfMassFixation(ClearCLBuffer input, ClearCLBuffer destination, Float relative_center_x, Float relative_center_y, Float relative_center_z)";
       description = "<b>driftCorrectionByCenterOfMassFixation</b><br><br>Determines the centerOfMass of the image stack and translates it so that it stays in a defined position.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float relative_center_x, Float relative_center_y, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.driftCorrectionByCentroidFixation(ClearCLBuffer input, ClearCLBuffer destination, Float relative_center_x, Float relative_center_y, Float relative_center_z, Float threshold)";
       description = "<b>driftCorrectionByCentroidFixation</b><br><br>Threshold the image stack, determines the centroid of the resulting binary image and <br>translates the image stack so that its centroid sits in a defined position.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float relative_center_x, Float relative_center_y, Float relative_center_z, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.entropyBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>entropyBox</b><br><br>Determines the local entropy in a box with a given radius around every pixel.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equal(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>equal</b><br><br>Determines if two images A and B equal pixel wise. <br><br><pre>f(a, b) = 1 if a == b; 0 otherwise.</pre> <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>equalConstant</b><br><br>Determines if an image A and a constant b are equal.<br><br><pre>f(a, b) = 1 if a == b; 0 otherwise.</pre> <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalizeMeanIntensitiesOfSlices(ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice)";
       description = "<b>equalizeMeanIntensitiesOfSlices</b><br><br>Determines correction factors for each z-slice so that the average intensity in all slices can be made the same and multiplies these factors with the slices. <br><br>This functionality is similar to the 'Simple Ratio Bleaching Correction' in Fiji.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabels(ClearCLBuffer binary_flaglist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabels</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a binary flag list vector starting with a flag for the background, continuing with label1, label2, ...<br><br>For example if you pass 0,1,0,0,1: Labels 1 and 4 will be removed (those with a 1 in the vector will be excluded). Labels 2 and 3 will be kept and renumbered to 1 and 2.<br><br>Parameters:<br>ClearCLBuffer binary_flaglist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOnEdges(ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabelsOnEdges</b><br><br>Removes all labels from a label map which touch the edges of the image (in X, Y and Z if the image is 3D). <br><br>Remaining label elements are renumbered afterwards.<br><br>Parameters:<br>ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOnSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsOnSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. <br><br>If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOutsideSizeRange(ClearCLBuffer input, ClearCLBuffer destination, Float minimum_size, Float maximum_size)";
       description = "<b>excludeLabelsOutsideSizeRange</b><br><br>Removes labels from a label map which are not within a certain size range.<br><br>Size of the labels is given as the number of pixel or voxels per label.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float minimum_size, Float maximum_size";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsSubSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsSubSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. <br><br>If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsWithValuesOutOfRange(ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range)";
       description = "<b>excludeLabelsWithValuesOutOfRange</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a vector of values and a range specifying which labels with which values are eliminated.<br><br>Parameters:<br>ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsWithValuesWithinRange(ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range)";
       description = "<b>excludeLabelsWithValuesWithinRange</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a vector of values and a range specifying which labels with which values are eliminated.<br><br>Parameters:<br>ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.exponential(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>exponential</b><br><br>Computes base exponential of all pixels values.<br><br>f(x) = exp(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.extendLabelingViaVoronoi(ClearCLBuffer input, ClearCLImageInterface destination)";
       description = "<b>extendLabelingViaVoronoi</b><br><br>Takes a label map image and dilates the regions using a octagon shape until they touch. <br><br>The resulting label map is written to the output.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.extendLabelsWithMaximumRadius(ClearCLBuffer input, ClearCLBuffer destination, Integer radius)";
       description = "<b>extendLabelsWithMaximumRadius</b><br><br>Extend labels with a given radius.<br><br>This is actually a local maximum filter applied to a label map which does not overwrite labels.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.extrema(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination)";
       description = "<b>extrema</b><br><br>Returns an image with pixel values most distant from 0: <br><br>f(x, y) = x if abs(x) > abs(y), y else.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.fillHistogram(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>fillHistogram</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.findAndLabelMaxima(ClearCLBuffer input, ClearCLBuffer destination, Float tolerance, Boolean invert)";
       description = "<b>findAndLabelMaxima</b><br><br>Determine maxima with a given tolerance to surrounding maxima and background and label them.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float tolerance, Boolean invert";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.findMaxima(ClearCLBuffer source, ClearCLBuffer destination, Float noise_threshold)";
       description = "<b>findMaxima</b><br><br>Finds and labels local maxima with neighboring maxima and background above a given tolerance threshold.<br><br><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float noise_threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip2D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip2D</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip3D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ)";
       description = "<b>flip3D</b><br><br>Flips an image in X, Y and/or Z direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.floodFillDiamond(ClearCLBuffer source, ClearCLBuffer destination, Float value_to_replace, Float value_replacement)";
       description = "<b>floodFillDiamond</b><br><br>Replaces recursively all pixels of value a with value b if the pixels have a neighbor with value b.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float value_to_replace, Float value_replacement";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussJordan(ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination)";
       description = "<b>gaussJordan</b><br><br>Gauss Jordan elimination algorithm for solving linear equation systems. <br><br>Ent the equation coefficients as an n*n sized image A and an n*1 sized image B:<br><pre>a(1,1)*x + a(2,1)*y + a(3,1)+z = b(1)<br>a(2,1)*x + a(2,2)*y + a(3,2)+z = b(2)<br>a(3,1)*x + a(3,2)*y + a(3,3)+z = b(3)<br></pre><br>The results will then be given in an n*1 image with values [x, y, z].<br><br>Adapted from: <br>https://github.com/qbunia/rodinia/blob/master/opencl/gaussian/gaussianElim_kernels.cl<br>L.G. Szafaryn, K. Skadron and J. Saucerman. &quot;Experiences Accelerating MATLAB Systems<br>//Biology Applications.&quot; in Workshop on Biomedicine in Computing (BiC) at the International<br>//Symposium on Computer Architecture (ISCA), June 2009.<br><br>Parameters:<br>ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>gaussianBlur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>gaussianBlur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>gaussianBlur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateBinaryOverlapMatrix(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer touch_matrix_destination)";
       description = "<b>generateBinaryOverlapMatrix</b><br><br>Takes two labelmaps with n and m labels and generates a (n+1)*(m+1) matrix where all pixels are set to 0 exept those where labels overlap between the label maps. <br><br>For example, if labels 3 in labelmap1 and 4 in labelmap2 are touching then the pixel (3,4) in the matrix will be set to 1.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer touch_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateDistanceMatrix(ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination)";
       description = "<b>generateDistanceMatrix</b><br><br>Takes two images containing coordinates and builds up a matrix containing distance between the points. <br><br>Convention: image width represents number of points, height represents dimensionality (2D, 3D, ... 10D). The result image has width the first input image and height equals to the width of the second input image.<br><br>Parameters:<br>ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateFeatureStack(ClearCLBuffer input, ClearCLBuffer feature_stack_destination, String feature_definitions)";
       description = "<b>generateFeatureStack</b><br><br>Generates a feature stack for Trainable Weka Segmentation. <br><br>Use this terminology to specifiy which stacks should be generated:<br>* &quot;original&quot; original slice<br>* &quot;GaussianBlur=s&quot; Gaussian blurred image with sigma s<br>* &quot;LaplacianOfGaussian=s&quot; Laplacian of Gaussian blurred image with sigma s<br>* &quot;SobelOfGaussian=s&quot; Sobel filter applied to Gaussian blurred image with sigma s<br>* &quot;minimum=r&quot; local minimum with radius r<br>* &quot;maximum=r&quot; local maximum with radius r<br>* &quot;mean=r&quot; local mean with radius r<br>* &quot;entropy=r&quot; local entropy with radius r<br>* &quot;gradientX&quot; local gradient in X direction<br>* &quot;gradientY&quot; local gradient in Y direction<br><br>Use sigma=0 to apply a filter to the original image. Feature definitions are not case sensitive.<br><br>Example: &quot;original gaussianBlur=1 gaussianBlur=5 laplacianOfGaussian=1 laplacianOfGaussian=7 entropy=3&quot;<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer feature_stack_destination, String feature_definitions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateGreyValueCooccurrenceMatrixBox(ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination, Float min_grey_value, Float max_grey_value)";
       description = "<b>generateGreyValueCooccurrenceMatrixBox</b><br><br>Takes an image and an intensity range to determine a grey value co-occurrence matrix.<br><br>For determining which pixel intensities are neighbors, the box neighborhood is taken into account.<br>Pixels with intensity below minimum of the given range are considered having the minimum intensity.<br>Pixels with intensity above the maximimum of the given range are treated analogously.<br>The resulting co-occurrence matrix contains probability values between 0 and 1.<br><br>Parameters:<br>ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination, Float min_grey_value, Float max_grey_value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateIntegerGreyValueCooccurrenceCountMatrixHalfBox(ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination)";
       description = "<b>generateIntegerGreyValueCooccurrenceCountMatrixHalfBox</b><br><br>Takes an image and assumes its grey values are integers. It builds up a grey-level co-occurrence matrix of neighboring (west, south-west, south, south-east, in 3D 9 pixels on the next plane) pixel intensities. <br><br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateIntegerGreyValueCooccurrenceCountMatrixHalfDiamond(ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination)";
       description = "<b>generateIntegerGreyValueCooccurrenceCountMatrixHalfDiamond</b><br><br>Takes an image and assumes its grey values are integers. It builds up a grey-level co-occurrence matrix of neighboring (left, bottom, back) pixel intensities. <br><br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer integer_image, ClearCLBuffer grey_value_cooccurrence_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateJaccardIndexMatrix(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer jaccard_index_matrix_destination)";
       description = "<b>generateJaccardIndexMatrix</b><br><br>Takes two labelmaps with n and m labels_2 and generates a (n+1)*(m+1) matrix where all labels_1 are set to 0 exept those where labels_2 overlap between the label maps. <br><br>For the remaining labels_1, the value will be between 0 and 1 indicating the overlap as measured by the Jaccard Index.<br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer jaccard_index_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateLabelFeatureImage(ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer label_feature_image_destination, String feature_definitions)";
       description = "<b>generateLabelFeatureImage</b><br><br>Generates a feature image for Trainable Weka Segmentation. <br><br>Use this terminology to specify which features should be generated:<br>* BOUNDING_BOX_DEPTH<br>* BOUNDING_BOX_WIDTH<br>* BOUNDING_BOX_HEIGHT<br>* CENTROID_X<br>* CENTROID_Y<br>* CENTROID_Z<br>* MASS_CENTER_X<br>* MASS_CENTER_Y<br>* MASS_CENTER_Z<br>* MAX_DISTANCE_TO_CENTROID<br>* MAX_DISTANCE_TO_MASS_CENTER<br>* MEAN_DISTANCE_TO_CENTROID<br>* MEAN_DISTANCE_TO_MASS_CENTER<br>* MAX_MEAN_DISTANCE_TO_CENTROID_RATIO<br>* MAX_MEAN_DISTANCE_TO_MASS_CENTER_RATIO<br>* MAXIMUM_INTENSITY<br>* MEAN_INTENSITY<br>* MINIMUM_INTENSITY<br>* SUM_INTENSITY<br>* STANDARD_DEVIATION_INTENSITY<br>* PIXEL_COUNT<br>* local_mean_average_distance_of_touching_neighbors<br>* local_maximum_average_distance_of_touching_neighbors<br>* count_touching_neighbors<br>* local_minimum_average_distance_of_touching_neighbors<br>* average_touch_pixel_count<br>* local_minimum_count_touching_neighbors<br>* average_distance_n_closest_neighbors<br>* average_distance_of_touching_neighbors<br>* local_mean_count_touching_neighbors<br>* local_mean_average_distance_n_closest_neighbors<br>* local_maximum_average_distance_n_closest_neighbors<br>* local_standard_deviation_average_distance_of_touching_neighbors<br>* local_maximum_count_touching_neighbors<br>* local_standard_deviation_count_touching_neighbors<br>* local_standard_deviation_average_distance_n_closest_neighbors<br>* local_minimum_average_distance_n_closest_neighbors<br><br>Example: &quot;MEAN_INTENSITY count_touching_neighbors&quot;<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer label_feature_image_destination, String feature_definitions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateParametricImage(ClearCLImageInterface label_map, ClearCLImageInterface parameter_value_vector, ClearCLImageInterface parametric_image_destination)";
       description = "<b>generateParametricImage</b><br><br>Take a labelmap and a vector of values to replace label 1 with the 1st value in the vector. <br><br>Note that indexing in the vector starts at zero. The 0th entry corresponds to background in the label map.Internally this method just calls ReplaceIntensities.<br><br><br>Parameters:<br>ClearCLImageInterface label_map, ClearCLImageInterface parameter_value_vector, ClearCLImageInterface parametric_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateParametricImageFromResultsTableColumn(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ResultsTable arg3, String arg4)";
       description = "<b>generateParametricImageFromResultsTableColumn</b><br><br>Take a labelmap and a column from the results table to replace label 1 with the 1st value in the vector. <br><br>Note that indexing in the table column starts at zero. The results table should contain a line at the beginningrepresenting the background.<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ResultsTable arg3, String arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateTouchCountMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_count_matrix_destination)";
       description = "<b>generateTouchCountMatrix</b><br><br>Takes a label map with n labels and generates a (n+1)*(n+1) matrix where all pixels are set the number of pixels where labels touch (diamond neighborhood). <br><br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_count_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateTouchMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination)";
       description = "<b>generateTouchMatrix</b><br><br>Takes a labelmap with n labels and generates a (n+1)*(n+1) matrix where all pixels are set to 0 exept those where labels are touching. <br><br>Only half of the matrix is filled (with x < y). For example, if labels 3 and 4 are touching then the pixel (3,4) in the matrix will be set to 1.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getAutomaticThreshold(ClearCLBuffer arg1, String arg2)";
       description = "<b>getAutomaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to determine a threshold value as similar as possible to ImageJ 'Apply Threshold' method. <br><br>Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getBoundingBox(ClearCLBuffer arg1)";
       description = "<b>getBoundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. <br><br>If called from macro, the positions will be stored in the variables 'boundingBoxX', 'boundingBoxY', 'boundingBoxZ', 'boundingBoxWidth', 'boundingBoxHeight' and 'boundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getCenterOfMass(ClearCLBuffer arg1)";
       description = "<b>getCenterOfMass</b><br><br>Determines the center of mass of an image or image stack.<br><br> It writes the result in the variables<br> centerOfMassX, centerOfMassY and centerOfMassZ.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getDimensions(ClearCLBuffer arg1)";
       description = "<b>getDimensions</b><br><br>Reads out the size of an image [stack] and writes it to the variables 'width', 'height' and 'depth'.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getGPUProperties(null)";
       description = "<b>getGPUProperties</b><br><br>Reads out properties of the currently active GPU and write it in the variables 'GPU_name', <br>'global_memory_in_bytes' and 'OpenCL_Version'.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getJaccardIndex(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getJaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getMaximumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMaximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. <br><br>It will be stored in the variable maximum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getMeanOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMeanOfAllPixels</b><br><br>Determines the mean of all pixels in a given image. <br><br>It will be stored in the variable mean_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getMeanOfMaskedPixels(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getMeanOfMaskedPixels</b><br><br>Determines the mean of all pixels in a given image which have non-zero value in a corresponding mask image. <br><br>It will be stored in the variable mean_of_masked_pixels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getMinimumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMinimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. <br><br>It will be stored in the variable minimum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSize(ClearCLBuffer source)";
       description = "<b>getSize</b><br><br>Reads out the size of an image [stack] and writes it to the results table in the columns 'Width', 'Height' and 'Depth'.<br><br>DEPRECATED: Thie method is <b>deprecated</b>. Use getDimensions instead.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSorensenDiceCoefficient(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getSorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getSumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in the variable sum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientX(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientX</b><br><br>Computes the gradient of gray values along X. <br><br>Assuming a, b and c are three adjacent<br> pixels in X direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientY(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientY</b><br><br>Computes the gradient of gray values along Y. <br><br>Assuming a, b and c are three adjacent<br> pixels in Y direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientZ(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientZ</b><br><br>Computes the gradient of gray values along Z. <br><br>Assuming a, b and c are three adjacent<br> pixels in Z direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greater(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greater</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterConstant</b><br><br>Determines if two images A and B greater pixel wise. <br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greaterOrEqual</b><br><br>Determines if two images A and B greater or equal pixel wise. <br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqualConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterOrEqualConstant</b><br><br>Determines if two images A and B greater or equal pixel wise. <br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greyLevelAtttributeFiltering(ClearCLBuffer source, ClearCLBuffer destination, Integer number_of_bins, Integer minimum_pixel_count)";
       description = "<b>greyLevelAtttributeFiltering</b><br><br>Inspired by Grayscale attribute filtering from MorpholibJ library by David Legland & Ignacio Arganda-Carreras.<br><br>This plugin will remove components in a grayscale image based on user-specified area (for 2D: pixels) or volume (3D: voxels).<br>For each gray level specified in the number of bins, binary images will be generated, followed by exclusion of objects (labels)<br>below a minimum pixel count.<br>All the binary images for each gray level are combined to form the final image. The output is a grayscale image, where bright objects<br>below pixel count are removed.<br>It is recommended that low values be used for number of bins, especially for large 3D images, or it may take long time.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer number_of_bins, Integer minimum_pixel_count";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.histogram(ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax)";
       description = "<b>histogram</b><br><br>Determines the histogram of a given image.<br><br>The histogram image is of dimensions number_of_bins/1/1; a 3D image with height=1 and depth=1. <br>Histogram bins contain the number of pixels with intensity in this corresponding bin. <br>The histogram bins are uniformly distributed between given minimum and maximum grey value intensity. <br>If the flag determine_min_max is set, minimum and maximum intensity will be determined. <br>When calling this operation many times, it is recommended to determine minimum and maximum intensity <br>once at the beginning and handing over these values.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.image2DToResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>image2DToResultsTable</b><br><br>Converts an image into a table.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.imageToStack(ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices)";
       description = "<b>imageToStack</b><br><br>Copies a single slice into a stack a given number of times.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.intensityCorrection(ClearCLBuffer input, ClearCLBuffer destination, Float reference_mean_intensity)";
       description = "<b>intensityCorrection</b><br><br>Determines the mean intensity of the image stack and multiplies it with a factor so that the mean intensity becomes equal to a given value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float reference_mean_intensity";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.intensityCorrectionAboveThresholdOtsu(ClearCLBuffer input, ClearCLBuffer destination, Float reference_mean_intensity)";
       description = "<b>intensityCorrectionAboveThresholdOtsu</b><br><br>Determines the mean intensity of all pixel the image stack which are above a determined Threshold (Otsu et al. 1979) and multiplies it with a factor so that the mean intensity becomes equal to a given value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float reference_mean_intensity";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.invalidateKernelCache(null)";
       description = "<b>invalidateKernelCache</b><br><br>Invalidates all cached OpenCL programs and kernels.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.invert(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>invert</b><br><br>Computes the negative value of all pixels in a given image. <br><br>It is recommended to convert images to <br>32-bit float before applying this operation.<br><br><pre>f(x) = - x</pre><br><br>For binary images, use binaryNot.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.jaccardIndex(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>jaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelMaximumExtensionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelMaximumExtensionMap</b><br><br>Takes a label map, determines for every label the maximum distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelMaximumExtensionRatioMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelMaximumExtensionRatioMap</b><br><br>Takes a label map, determines for every label the maximum distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelMaximumIntensityMap(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3)";
       description = "<b>labelMaximumIntensityMap</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelMeanIntensityMap(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3)";
       description = "<b>labelMeanIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the mean intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelMinimumIntensityMap(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3)";
       description = "<b>labelMinimumIntensityMap</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelPixelCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelPixelCountMap</b><br><br>Takes a label map, determines the number of pixels per label and replaces every label with the that number.<br><br>This results in a parametric image expressing area or volume.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelSpots(ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination)";
       description = "<b>labelSpots</b><br><br>Transforms a binary image with single pixles set to 1 to a labelled spots image. <br><br>Transforms a spots image as resulting from maximum/minimum detection in an image of the same size where every spot has a number 1, 2, ... n.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelStandardDeviationIntensityMap(ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>labelStandardDeviationIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the standard deviation of the intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing standard deviation of object intensity.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelToMask(ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index)";
       description = "<b>labelToMask</b><br><br>Masks a single label in a label map. <br><br>Sets all pixels in the target image to 1, where the given label index was present in the label map. Other pixels are set to 0.<br><br>Parameters:<br>ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelVoronoiOctagon(ClearCLBuffer label_map, ClearCLBuffer label_voronoi_destination)";
       description = "<b>labelVoronoiOctagon</b><br><br>Takes a labelled image and dilates the labels using a octagon shape until they touch. <br><br>The pixels where  the regions touched are afterwards returned as binary image which corresponds to the Voronoi diagram.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer label_voronoi_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelledSpotsToPointList(ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>labelledSpotsToPointList</b><br><br>Generates a coordinate list of points in a labelled spot image. <br><br>Transforms a labelmap of spots (single pixels with values 1, 2, ..., n for n spots) as resulting <br>from connected components analysis in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceBox(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceBox</b><br><br>Applies the Laplace operator (Box neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceSphere(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceSphere</b><br><br>Applies the Laplace operator (Diamond neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localDoGThreshold(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>localDoGThreshold</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localExtremaBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>localExtremaBox</b><br><br>Applies a local minimum and maximum filter. <br><br>Afterwards, the value is returned which is more far from zero.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localID(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localID</b><br><br>local id<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMaximumAverageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>localMaximumAverageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids, the mean distance of the n closest points for every point<br> and replaces every label with the maximum distance of touching labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMaximumAverageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMaximumAverageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch, the distance between their centroids and the maximum distancebetween touching neighbors. It then replaces every label with the that value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMaximumTouchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMaximumTouchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch, determines for every label with the number of touching <br>neighboring labels and replaces the label index with the local maximum of this count.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMeanAverageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>localMeanAverageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids, the mean distance of the n closest points for every point<br> and replaces every label with the mean distance of touching labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMeanAverageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMeanAverageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch, the distance between their centroids and the mean distancebetween touching neighbors. It then replaces every label with the that value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMeanTouchPortionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMeanTouchPortionMap</b><br><br>Takes a label map, determines which labels touch and how much, relatively taking the whole outline of <br>each label into account, and determines for every label with the mean of this value and replaces the <br>label index with that value.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMeanTouchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMeanTouchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch, determines for every label with the number of touching <br>neighboring labels and replaces the label index with the local mean of this count.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMedianAverageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>localMedianAverageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids, the mean distance of the n closest points for every point<br> and replaces every label with the median distance of touching labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMedianAverageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMedianAverageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch, the distance between their centroids and the median distancebetween touching neighbors. It then replaces every label with the that value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMedianTouchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMedianTouchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch, determines for every label with the number of touching <br>neighboring labels and replaces the label index with the local median of this count.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMinimumAverageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>localMinimumAverageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids, the mean distance of the n closest points for every point<br> and replaces every label with the minimum distance of touching labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMinimumAverageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMinimumAverageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch, the distance between their centroids and the minimum distancebetween touching neighbors. It then replaces every label with the that value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localMinimumTouchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localMinimumTouchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch, determines for every label with the number of touching <br>neighboring labels and replaces the label index with the local minimum of this count.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localStandardDeviationAverageDistanceOfNClosestNeighborsMap(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>localStandardDeviationAverageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids, the mean distance of the n closest points for every point<br> and replaces every label with the standard deviation distance of touching labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localStandardDeviationAverageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localStandardDeviationAverageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch, the distance between their centroids and the standard deviation distancebetween touching neighbors. It then replaces every label with the that value.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localStandardDeviationTouchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localStandardDeviationTouchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch, determines for every label with the number of touching <br>neighboring labels and replaces the label index with the local standard deviation of this count.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localThreshold(ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination)";
       description = "<b>localThreshold</b><br><br>Computes a binary image with pixel values 0 and 1 depending on if a pixel value x in image X <br>was above of equal to the pixel value m in mask image M.<br><br><pre>f(x) = (1 if (x >=  m)); (0 otherwise)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.logarithm(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>logarithm</b><br><br>Computes base e logarithm of all pixels values.<br><br>f(x) = log(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.makeIsoTropic(ClearCLBuffer input, ClearCLBuffer destination, Float original_voxel_size_x, Float original_voxel_size_y, Float original_voxel_size_z, Float new_voxel_size)";
       description = "<b>makeIsoTropic</b><br><br>Applies a scaling operation using linear interpolation to generate an image stack with a given isotropic voxel size.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float original_voxel_size_x, Float original_voxel_size_y, Float original_voxel_size_z, Float new_voxel_size";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mask(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>mask</b><br><br>Computes a masked image by applying a binary mask to an image. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskLabel(ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index)";
       description = "<b>maskLabel</b><br><br>Computes a masked image by applying a label mask to an image. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the label_map image has the right index value i.<br><br>f(x,m,i) = (x if (m == i); (0 otherwise))<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskStackWithPlane(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>maskStackWithPlane</b><br><br>Computes a masked image by applying a binary 2D mask to an image stack. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same spatial position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.matrixEqual(ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance)";
       description = "<b>matrixEqual</b><br><br>Checks if all elements of a matrix are different by less than or equal to a given tolerance. <br><br>The result will be put in the results table in column &quot;MatrixEqual&quot; as 1 if yes and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DBox</b><br><br>Computes the local maximum of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum3DSliceBySliceSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal 2D neighborhood in an image stack slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DSphere</b><br><br>Computes the local maximum of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximumBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>maximumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>maximumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X. <br><br><pre>f(x, s) = max(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>maximumImages</b><br><br>Computes the maximum of a pair of pixel values x, y from two given images X and Y. <br><br><pre>f(x, y) = max(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>maximumOctagon</b><br><br>Applies a maximum filter with kernel size 3x3 n times to an image iteratively. <br><br>Odd iterations are done with box neighborhood, even iterations with a diamond. <br>Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter <br>result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>maximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Max'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>maximumOfMaskedPixels</b><br><br>Determines the maximum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer maximum_values_destination)";
       description = "<b>maximumOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the maximum value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer maximum_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumXProjection</b><br><br>Determines the maximum intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumYProjection</b><br><br>Determines the maximum intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumZProjection</b><br><br>Determines the maximum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_max, Integer min_z, Integer max_z)";
       description = "<b>maximumZProjectionBounded</b><br><br>Determines the maximum intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DBox</b><br><br>Computes the local mean average of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DSphere</b><br><br>Computes the local mean average of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>meanBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanClosestSpotDistance(ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional)";
       description = "<b>meanClosestSpotDistance</b><br><br>Determines the distance between pairs of closest spots in two binary images. <br><br>Takes two binary images A and B with marked spots and determines for each spot in image A the closest spot in image B. Afterwards, it saves the average shortest distances from image A to image B as 'mean_closest_spot_distance_A_B' and from image B to image A as 'mean_closest_spot_distance_B_A' to the results table. The distance between B and A is only determined if the `bidirectional` checkbox is checked.<br><br>Parameters:<br>ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfAllPixels(ClearCLImageInterface source)";
       description = "<b>meanOfAllPixels</b><br><br>Determines the mean average of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Mean'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>meanOfMaskedPixels</b><br><br>Determines the mean intensity in a masked image. <br><br>Only in pixels which have non-zero values in another binary mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfPixelsAboveThreshold(ClearCLBuffer source, Float threshold)";
       description = "<b>meanOfPixelsAboveThreshold</b><br><br>Determines the mean intensity in a threshleded image. <br><br>But only in pixels which are above a given threshold.<br><br>Parameters:<br>ClearCLBuffer source, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination)";
       description = "<b>meanOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the mean value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>meanSliceBySliceSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSquaredError(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>meanSquaredError</b><br><br>Determines the mean squared error (MSE) between two images. <br><br>The MSE will be stored in a new row of ImageJs<br>Results table in the column 'MSE'.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanXProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanXProjection</b><br><br>Determines the mean average intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanYProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanYProjection</b><br><br>Determines the mean average intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanZProjection</b><br><br>Determines the mean average intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjectionAboveThreshold(ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold)";
       description = "<b>meanZProjectionAboveThreshold</b><br><br>Determines the mean average intensity projection of an image along Z but only for pixels above a given threshold.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_mean, Integer min_z, Integer max_z)";
       description = "<b>meanZProjectionBounded</b><br><br>Determines the mean average intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_mean, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. <br><br>The rectangle is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DBox</b><br><br>Computes the local median of a pixels cuboid neighborhood. <br><br>The cuboid size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the cuboid must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. <br><br>This is done slice-by-slice in a 3D <br>image stack. The rectangle is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. <br><br>This is done slice-by-slice in a 3D <br>image stack. The ellipses size is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DSphere</b><br><br>Computes the local median of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the sphere must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.medianOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination)";
       description = "<b>medianOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the median value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.medianZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>medianZProjection</b><br><br>Determines the median intensity projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mergeTouchingLabels(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>mergeTouchingLabels</b><br><br><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mergeTouchingLabelsSpecial(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4)";
       description = "<b>mergeTouchingLabelsSpecial</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DBox</b><br><br>Computes the local minimum of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum3DSliceBySliceSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DSphere</b><br><br>Computes the local minimum of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimumBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>minimumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination)";
       description = "<b>minimumDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the shortest distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>minimumImageAndScalar</b><br><br>Computes the minimum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = min(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>minimumImages</b><br><br>Computes the minimum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = min(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>minimumOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. <br><br>Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>minimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Min'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>minimumOfMaskedPixels</b><br><br>Determines the minimum intensity in a masked image. <br><br>But only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_values_destination)";
       description = "<b>minimumOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the minimum value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>minimumXProjection</b><br><br>Determines the minimum intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>minimumYProjection</b><br><br>Determines the minimum intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>minimumZProjection</b><br><br>Determines the minimum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_min, Integer min_z, Integer max_z)";
       description = "<b>minimumZProjectionBounded</b><br><br>Determines the minimum intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_min, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjectionThresholdedBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5)";
       description = "<b>minimumZProjectionThresholdedBounded</b><br><br>Determines the minimum intensity projection of all pixels in an image above a given threshold along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndCoordinate(ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension)";
       description = "<b>multiplyImageAndCoordinate</b><br><br>Multiplies all pixel intensities with the x, y or z coordinate, depending on specified dimension.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>multiplyImageAndScalar</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageStackWithScalars(ClearCLImageInterface arg1, ClearCLImageInterface arg2, float[] arg3)";
       description = "<b>multiplyImageStackWithScalars</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s from a list of scalars.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, float[] arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImages(ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination)";
       description = "<b>multiplyImages</b><br><br>Multiplies all pairs of pixel values x and y from two image X and Y.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyMatrix(ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination)";
       description = "<b>multiplyMatrix</b><br><br>Multiplies two matrices with each other.<br><br>Parameters:<br>ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyStackWithPlane(ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination)";
       description = "<b>multiplyStackWithPlane</b><br><br>Multiplies all pairs of pixel values x and y from an image stack X and a 2D image Y. <br><br>x and y are at <br>the same spatial position within a plane.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nClosestDistances(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3)";
       description = "<b>nClosestDistances</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix. <br><br>This corresponds to the n row indices with minimum values for each column of the distance matrix.Returns the n shortest distances in one image and the point indices in another image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>nClosestPoints</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix. <br><br>This corresponds to the n row indices with minimum values for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.neighborsOfNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer neighbor_matrix_destination)";
       description = "<b>neighborsOfNeighbors</b><br><br>Determines neighbors of neigbors from touch matrix and saves the result as a new touch matrix.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer neighbor_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonLocalMeans(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ, Float sigma)";
       description = "<b>nonLocalMeans</b><br><br>Applies a non-local means filter using a box neighborhood with a Gaussian weight specified with sigma to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ, Float sigma";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMaximumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>nonzeroMaximumBox</b><br><br>Apply a maximum filter (box shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMaximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>nonzeroMaximumDiamond</b><br><br>Apply a maximum filter (diamond shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMinimumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>nonzeroMinimumBox</b><br><br>Apply a minimum filter (box shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMinimumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>nonzeroMinimumDiamond</b><br><br>Apply a minimum filter (diamond shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination)";
       description = "<b>notEqual</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>notEqualConstant</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.onlyzeroOverwriteMaximumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>onlyzeroOverwriteMaximumBox</b><br><br>Apply a local maximum filter to an image which only overwrites pixels with value 0.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.onlyzeroOverwriteMaximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>onlyzeroOverwriteMaximumDiamond</b><br><br>Apply a local maximum filter to an image which only overwrites pixels with value 0.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingBox</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingDiamond</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.organiseWindows(Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight)";
       description = "<b>organiseWindows</b><br><br>Organises windows on screen.<br><br>Parameters:<br>Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.parametricWatershed(ClearCLBuffer binary_source, ClearCLBuffer destination, Float sigma_x, Float sigma_y, Float sigma_z)";
       description = "<b>parametricWatershed</b><br><br>Apply a binary watershed to a binary image and introduce black pixels between objects.<br><br>To have control about where objects are cut, the sigma parameters allow to control a Gaussian blur filter applied to the internally used distance map.<br><br>Parameters:<br>ClearCLBuffer binary_source, ClearCLBuffer destination, Float sigma_x, Float sigma_y, Float sigma_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ)";
       description = "<b>particleImageVelocimetry</b><br><br>For every pixel in source image 1, determine the pixel with the most similar intensity in <br> the local neighborhood with a given radius in source image 2. Write the distance in <br>X, Y and Z in the three corresponding destination images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry2D(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, Integer arg5)";
       description = "<b>particleImageVelocimetry2D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetryTimelapse(ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift)";
       description = "<b>particleImageVelocimetryTimelapse</b><br><br>Run particle image velocimetry on a 2D+t timelapse.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY)";
       description = "<b>paste</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste2D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY)";
       description = "<b>paste2D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste3D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY, Integer destinationZ)";
       description = "<b>paste3D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY, Integer destinationZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pointIndexListToMesh(ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer mesh_destination)";
       description = "<b>pointIndexListToMesh</b><br><br>Meshes all points in a given point list which are indiced in a corresponding index list.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pointlistToLabelledSpots(ClearCLBuffer pointlist, ClearCLBuffer spots_destination)";
       description = "<b>pointlistToLabelledSpots</b><br><br>Takes a pointlist with dimensions n times d with n point coordinates in d dimensions and labels corresponding pixels.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.popMetaData(null)";
       description = "<b>popMetaData</b><br><br>Takes meta data from a stack and assigns it to the current image. The stack implements the Last-In-First-Out (LIFO) principle.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.power(ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent)";
       description = "<b>power</b><br><br>Computes all pixels value x to the power of a given exponent a.<br><br><pre>f(x, a) = x ^ a</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.powerImages(ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination)";
       description = "<b>powerImages</b><br><br>Calculates x to the power of y pixel wise of two images X and Y.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.preloadFromDisc(ClearCLBuffer destination, String filename, String nextFilename, String loaderId)";
       description = "<b>preloadFromDisc</b><br><br>This plugin takes two image filenames and loads them into RAM. The first image is returned immediately, the second image is loaded in the background and  will be returned when the plugin is called again.<br><br> It is assumed that all images have the same size. If this is not the case, call release(image) before  getting the second image.<br><br>Parameters:<br>ClearCLBuffer destination, String filename, String nextFilename, String loaderId";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.presign(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>presign</b><br><br>Determines the extrema of pixel values: <br><br>f(x) = x / abs(x).<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.print(ClearCLImageInterface input)";
       description = "<b>print</b><br><br>Visualises an image on standard out (console).<br><br>Parameters:<br>ClearCLImageInterface input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pull(null)";
       description = "<b>pull</b><br><br>Copies an image specified by its name from GPU memory back to ImageJ and shows it.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullAsROI(ClearCLBuffer binary_input)";
       description = "<b>pullAsROI</b><br><br>Pulls a binary image from the GPU memory and puts it on the currently active ImageJ window as region of interest.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullBinary(null)";
       description = "<b>pullBinary</b><br><br>Copies a binary image specified by its name from GPU memory back to ImageJ and shows it. This binary image will have 0 and 255 pixel intensities as needed for ImageJ to interpret it as binary.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIList(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIList</b><br><br>Pulls all labels in a label map as ROIs to a list. <br><br>From ImageJ macro this list is written to the log <br>window. From ImageJ macro conside using pullLabelsToROIManager.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIManager(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIManager</b><br><br>Pulls all labels in a label map as ROIs to the ROI manager.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullString(ClearCLImageInterface arg1)";
       description = "<b>pullString</b><br><br>Writes an image into a string.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullTile(ImagePlus arg1, String arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10, int arg11)";
       description = "<b>pullTile</b><br><br>Pushes a tile in an image specified by its name, position and size from GPU memory.<br><br>Parameters:<br>ImagePlus arg1, String arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10, int arg11";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullToResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>pullToResultsTable</b><br><br>Converts an image into a table.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.push(null)";
       description = "<b>push</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushArray(ClearCLBuffer arg1, Object arg2)";
       description = "<b>pushArray</b><br><br>Converts an array to an image.<br><br>Parameters:<br>ClearCLBuffer arg1, Object arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushCurrentSelection(null)";
       description = "<b>pushCurrentSelection</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushCurrentSlice(null)";
       description = "<b>pushCurrentSlice</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushCurrentSliceSelection(null)";
       description = "<b>pushCurrentSliceSelection</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushCurrentZStack(null)";
       description = "<b>pushCurrentZStack</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushMetaData(null)";
       description = "<b>pushMetaData</b><br><br>Stores meta data in a stack. The stack implements the Last-In-First-Out (LIFO) principle.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>pushResultsTable</b><br><br>Converts a table to an image. <br><br>Rows stay rows, columns stay columns.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushResultsTableColumn(ClearCLBuffer arg1, ResultsTable arg2, String arg3)";
       description = "<b>pushResultsTableColumn</b><br><br>Converts a table column to an image. <br><br>The values are stored in x dimension.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushString(ClearCLBuffer arg1, String arg2)";
       description = "<b>pushString</b><br><br>Converts an string to an image. <br><br>The formatting works with double line breaks for slice switches, single line breaks for y swithces and <br>spaces for x. For example this string is converted to an image with width=4, height=3 and depth=2:<br><br>1 2 3 4<br>5 6 7 8<br>9 0 1 2<br><br>3 4 5 6<br>7 8 9 0<br>1 2 3 4<br><br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pushTile(ImagePlus arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10)";
       description = "<b>pushTile</b><br><br>Push a tile in an image specified by its name, position and size to GPU memory in order to process it there later.<br><br>Parameters:<br>ImagePlus arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.radialProjection(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>radialProjection</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.readImageFromDisc(String arg1)";
       description = "<b>readImageFromDisc</b><br><br>Read an image from disc.<br><br>Parameters:<br>String arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.readRawImageFromDisc(ClearCLBuffer arg1, String arg2)";
       description = "<b>readRawImageFromDisc</b><br><br>Reads a raw file from disc and pushes it immediately to the GPU.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.reduceStack(ClearCLImageInterface input, ClearCLImageInterface destination, Integer reductionFactor, Integer offset)";
       description = "<b>reduceStack</b><br><br>Reduces the number of slices in a stack by a given factor.<br>With the offset you have control which slices stay: <br>* With factor 3 and offset 0, slices 0, 3, 6,... are kept. * With factor 4 and offset 1, slices 1, 5, 9,... are kept.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Integer reductionFactor, Integer offset";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.release(null)";
       description = "<b>release</b><br><br>Frees memory of a specified image in GPU memory.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensities(ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination)";
       description = "<b>replaceIntensities</b><br><br>Replaces integer intensities specified in a vector image. <br><br>The vector image must be 3D with size (m, 1, 1) where m corresponds to the maximum intensity in the original image. Assuming the vector image contains values (0, 1, 0, 2) means: <br> * All pixels with value 0 (first entry in the vector image) get value 0<br> * All pixels with value 1 get value 1<br> * All pixels with value 2 get value 0<br> * All pixels with value 3 get value 2<br><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensity(ClearCLImageInterface input, ClearCLImageInterface destination, Float oldValue, Float newValue)";
       description = "<b>replaceIntensity</b><br><br>Replaces a specific intensity in an image with a given new value.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float oldValue, Float newValue";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replacePixelsIfZero(ClearCLImageInterface input1, ClearCLImageInterface input2, ClearCLImageInterface destination)";
       description = "<b>replacePixelsIfZero</b><br><br>Replaces pixel values x with y in case x is zero.<br><br>This functionality is comparable to ImageJs image calculator operator 'transparent zero'.<br><br>Parameters:<br>ClearCLImageInterface input1, ClearCLImageInterface input2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.reportMemory(null)";
       description = "<b>reportMemory</b><br><br>Prints a list of all images cached in the GPU to ImageJs log window together with a sum of memory <br>consumption.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ, Boolean linearInterpolation)";
       description = "<b>resample</b><br><br>Resamples an image with given size factors using an affine transform.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ, Boolean linearInterpolation";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resample2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Boolean arg5)";
       description = "<b>resample2D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resample3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>resample3D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resetMetaData(null)";
       description = "<b>resetMetaData</b><br><br>Resets the meta data stack.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceBottom(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceBottom</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceLeft</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRadial(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>resliceRadial</b><br><br>Computes a radial projection of an image stack. <br><br>Starting point for the line is the given point in any <br>X/Y-plane of a given input image stack. Furthermore, radius of the resulting projection must be given and scaling factors in X and Y in case pixels are not isotropic.This operation is similar to ImageJs 'Radial Reslice' method but offers less flexibility.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRadialTop(null)";
       description = "<b>resliceRadialTop</b><br><br>Computes a radial projection of an image stack and reslices it from top. <br><br>Starting point for the line is the given point in any <br>X/Y-plane of a given input image stack. Furthermore, radius of the resulting projection must be given and scaling factors in X and Y in case pixels are not isotropic.This operation is similar to ImageJs 'Radial Reslice' method combined with 'Reslice from top' but offers less flexibility.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceRight</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceTop(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceTop</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resultsTableColumnToImage(ClearCLBuffer arg1, ResultsTable arg2, String arg3)";
       description = "<b>resultsTableColumnToImage</b><br><br>Converts a table column to an image. <br><br>The values are stored in x dimension.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resultsTableToImage2D(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>resultsTableToImage2D</b><br><br>Converts a table to an image. <br><br>Rows stay rows, columns stay columns.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rigidTransform(ClearCLBuffer input, ClearCLBuffer destination, Float translation_x, Float translation_y, Float translation_z, Float rotation_angle_x, Float rotation_angle_y, Float rotation_angle_z)";
       description = "<b>rigidTransform</b><br><br>Applies a rigid transform using linear interpolation to an image stack.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float translation_x, Float translation_y, Float translation_z, Float rotation_angle_x, Float rotation_angle_y, Float rotation_angle_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate2D(ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter)";
       description = "<b>rotate2D</b><br><br>Rotates an image in plane. <br><br>All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate3D(ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter)";
       description = "<b>rotate3D</b><br><br>Rotates an image stack in 3D. <br><br>All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateClockwise</b><br><br>Rotates a given input image by 90 degrees clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateCounterClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateCounterClockwise</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateLeft</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateRight</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.saveAsTIF(ClearCLBuffer input, String filename)";
       description = "<b>saveAsTIF</b><br><br>Pulls an image from the GPU memory and saves it as TIF to disc.<br><br>Parameters:<br>ClearCLBuffer input, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>scale</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>scale2D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale3D(ClearCLBuffer source, ClearCLBuffer destination, Float scaling_factor_x, Float scaling_factor_y, Float scaling_factor_z, Boolean scale_to_center)";
       description = "<b>scale3D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float scaling_factor_x, Float scaling_factor_y, Float scaling_factor_z, Boolean scale_to_center";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.seededWatershed(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4)";
       description = "<b>seededWatershed</b><br><br>Takes a label map (seeds) and an input image with gray values to apply the watershed algorithm and split the image above a given threshold in labels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.set(ClearCLImageInterface source, Float value)";
       description = "<b>set</b><br><br>Sets all pixel values x of a given image X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setColumn(ClearCLImageInterface source, Integer column_index, Float value)";
       description = "<b>setColumn</b><br><br>Sets all pixel values x of a given column in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer column_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setImageBorders(ClearCLImageInterface destination, Float value)";
       description = "<b>setImageBorders</b><br><br>Sets all pixel values at the image border to a given value.<br><br>Parameters:<br>ClearCLImageInterface destination, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setNonZeroPixelsToPixelIndex(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>setNonZeroPixelsToPixelIndex</b><br><br>Sets all pixels in an image which are not zero to the index of the pixel. <br><br>This can be used for Connected Components Analysis.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setPlane(ClearCLImageInterface source, Integer plane_index, Float value)";
       description = "<b>setPlane</b><br><br>Sets all pixel values x of a given plane in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer plane_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampX(ClearCLImageInterface source)";
       description = "<b>setRampX</b><br><br>Sets all pixel values to their X coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampY(ClearCLImageInterface source)";
       description = "<b>setRampY</b><br><br>Sets all pixel values to their Y coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampZ(ClearCLImageInterface source)";
       description = "<b>setRampZ</b><br><br>Sets all pixel values to their Z coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRandom(ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed)";
       description = "<b>setRandom</b><br><br>Fills an image or image stack with uniformly distributed random numbers between given minimum and maximum values. <br><br>Recommendation: For the seed, use getTime().<br><br>Parameters:<br>ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRow(ClearCLImageInterface source, Integer row_index, Float value)";
       description = "<b>setRow</b><br><br>Sets all pixel values x of a given row in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer row_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXequalsY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXequalsY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXgreaterThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXgreaterThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x > y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXsmallerThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXsmallerThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x < y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.shiftIntensitiesToCloseGaps(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>shiftIntensitiesToCloseGaps</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.shortestDistances(ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances)";
       description = "<b>shortestDistances</b><br><br>Determine the shortest distance from a distance matrix. <br><br>This corresponds to the minimum for each individial column.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGlasbeyOnGrey(ClearCLBuffer red, ClearCLBuffer labelling, String title)";
       description = "<b>showGlasbeyOnGrey</b><br><br>Visualises two 2D images as one RGB image. <br><br>The first channel is shown in grey, the second with glasbey LUT.<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer labelling, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGrey(ClearCLBuffer input, String title)";
       description = "<b>showGrey</b><br><br>Visualises a single 2D image.<br><br>Parameters:<br>ClearCLBuffer input, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showRGB(ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title)";
       description = "<b>showRGB</b><br><br>Visualises three 2D images as one RGB image<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.skeletonize(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>skeletonize</b><br><br>Erodes a binary image until just its skeleton is left. <br><br>The result is similar to Skeletonize3D in Fiji.<br><br>Deprecated: Use SimpleITK binaryThinning() instead.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smaller(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smaller</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerConstant</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqual(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smallerOrEqual</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerOrEqualConstant</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sobel(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>sobel</b><br><br>Convolve the image with the Sobel kernel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sorensenDiceCoefficient(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>sorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sphereTransform(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_y, Float relative_center_z)";
       description = "<b>sphereTransform</b><br><br>Turns an image stack in XYZ cartesian coordinate system to an AID polar coordinate system.<br><br>A corresponds to azimut,I to inclination and D to the distance from the center.Thus, going in virtual Z direction (actually D) in the resulting stack, you go from the center to theperiphery.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_y, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.spotsToPointList(ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>spotsToPointList</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.squaredDifference(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>squaredDifference</b><br><br>Determines the squared difference pixel by pixel between two images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stackToTiles(ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y)";
       description = "<b>stackToTiles</b><br><br>Stack to tiles.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfAllPixels(ClearCLImageInterface source)";
       description = "<b>standardDeviationOfAllPixels</b><br><br>Determines the standard deviation of all pixels in an image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Standard_deviation'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>standardDeviationOfMaskedPixels</b><br><br>Determines the standard deviation of all pixels in an image which have non-zero value in a corresponding mask image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Masked_standard_deviation'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer standard_deviation_values_destination)";
       description = "<b>standardDeviationOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the standard deviation value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer standard_deviation_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>standardDeviationZProjection</b><br><br>Determines the standard deviation intensity projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.startContinuousWebcamAcquisition(Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight)";
       description = "<b>startContinuousWebcamAcquisition</b><br><br>Starts acquistion of images from a webcam.<br><br>Parameters:<br>Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfBackgroundAndLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfBackgroundAndLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity <br> of background and labelled objects in a label map and corresponding pixels in the original image.<br><br>Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfImage(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>statisticsOfImage</b><br><br>Determines image size (bounding box), area (in pixels/voxels), min, max and mean intensity <br> of all pixels in the original image.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity <br> of labelled objects in a label map and corresponding pixels in the original image. <br><br>Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfLabelledPixels_single_threaded(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3, int arg4)";
       description = "<b>statisticsOfLabelledPixels_single_threaded</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopContinuousWebcamAcquisition(Integer cameraDeviceIndex)";
       description = "<b>stopContinuousWebcamAcquisition</b><br><br>Stops continous acquistion from a webcam.<br><br>Parameters:<br>Integer cameraDeviceIndex";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopWatch(String text)";
       description = "<b>stopWatch</b><br><br>Measures time and outputs delay to last call.<br><br>Parameters:<br>String text";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtract(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtract</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>subtractBackground</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Deprecated: Use topHat() or differenceOfGaussian() instead.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground2D(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>subtractBackground2D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Deprecated: Use topHat() or differenceOfGaussian() instead.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground3D(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>subtractBackground3D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Deprecated: Use topHat() or differenceOfGaussian() instead.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractGaussianBackground(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>subtractGaussianBackground</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Deprecated: Use differenceOfGaussian() instead.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImageFromScalar(ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar)";
       description = "<b>subtractImageFromScalar</b><br><br>Subtracts one image X from a scalar s pixel wise.<br><br><pre>f(x, s) = s - x</pre><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImages(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtractImages</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumImageSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumImageSliceBySlice</b><br><br>Sums all pixels slice by slice and returns them in an array.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>sumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumPixels(ClearCLImageInterface source)";
       description = "<b>sumPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumPixelsSliceByslice(ClearCLImageInterface arg1)";
       description = "<b>sumPixelsSliceByslice</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumXProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumYProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>sumZProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.tenengradFusion(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent)";
       description = "<b>tenengradFusion</b><br><br>Fuses #n# image stacks using Tenengrads algorithm.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.threshold(ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold)";
       description = "<b>threshold</b><br><br>Computes a binary image with pixel values 0 and 1. <br><br>All pixel values x of a given input image with <br>value larger or equal to a given threshold t will be set to 1.<br><br>f(x,t) = (1 if (x >= t); (0 otherwise))<br><br>This plugin is comparable to setting a raw threshold in ImageJ and using the 'Convert to Mask' menu.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdDefault(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdDefault</b><br><br>The automatic thresholder utilizes the Default threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdHuang(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdHuang</b><br><br>The automatic thresholder utilizes the Huang threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIJ_IsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIJ_IsoData</b><br><br>The automatic thresholder utilizes the IJ_IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIntermodes(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIntermodes</b><br><br>The automatic thresholder utilizes the Intermodes threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIsoData</b><br><br>The automatic thresholder utilizes the IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdLi(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdLi</b><br><br>The automatic thresholder utilizes the Li threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMaxEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMaxEntropy</b><br><br>The automatic thresholder utilizes the MaxEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMean(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMean</b><br><br>The automatic thresholder utilizes the Mean threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMinError(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinError</b><br><br>The automatic thresholder utilizes the MinError threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMinimum(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinimum</b><br><br>The automatic thresholder utilizes the Minimum threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMoments(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMoments</b><br><br>The automatic thresholder utilizes the Moments threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdOtsu(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdOtsu</b><br><br>The automatic thresholder utilizes the Otsu threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdPercentile(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdPercentile</b><br><br>The automatic thresholder utilizes the Percentile threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdRenyiEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdRenyiEntropy</b><br><br>The automatic thresholder utilizes the RenyiEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdShanbhag(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdShanbhag</b><br><br>The automatic thresholder utilizes the Shanbhag threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdTriangle(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdTriangle</b><br><br>The automatic thresholder utilizes the Triangle threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdYen(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdYen</b><br><br>The automatic thresholder utilizes the Yen threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatBox</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>topHatOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. <br><br> Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagonSliceBySlice(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>topHatOctagonSliceBySlice</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. <br><br>Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatSphere</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.touchMatrixToAdjacencyMatrix(ClearCLBuffer touch_matrix, ClearCLBuffer adjacency_matrix)";
       description = "<b>touchMatrixToAdjacencyMatrix</b><br><br>Converts a touch matrix in an adjacency matrix<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer adjacency_matrix";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.touchMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination)";
       description = "<b>touchMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a touch matrix of <br>size n*n to draw lines from all points to points if the corresponding pixel in the touch matrix is 1.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.touchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>touchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the number of touching neighboring labels.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainAutoContextWekaModelWithOptions(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3, String arg4, int arg5, Integer arg6, Integer arg7, Integer arg8)";
       description = "<b>trainAutoContextWekaModelWithOptions</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaFromTable(ResultsTable arg1, String arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>trainWekaFromTable</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin. <br><br>It takes the given Results Table, sorts its columns alphabetically as extracted features (rows correspond to feature vectors) and a given column name containing the ground truth to train a Weka model. This model will be saved to disc.<br>The given groundTruth column is supposed to be numeric with values 1 represent class 1,  value 2 represent class 2 and so on. Value 0 will be ignored for training.<br><br>Default values for options are:<br>* trees = 200<br>* features = 2<br>* maxDepth = 0<br><br>Parameters:<br>ResultsTable arg1, String arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename)";
       description = "<b>trainWekaModel</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin. <br><br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModelWithOptions(ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename, Integer trees, Integer features, Integer maxDepth)";
       description = "<b>trainWekaModelWithOptions</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin. <br><br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Default values for options are:<br>* trees = 200<br>* features = 2<br>* maxDepth = 0<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename, Integer trees, Integer features, Integer maxDepth";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate2D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY)";
       description = "<b>translate2D</b><br><br>Translate an image stack in X and Y.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate3D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ)";
       description = "<b>translate3D</b><br><br>Translate an image stack in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationRegistration(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination)";
       description = "<b>translationRegistration</b><br><br>Measures center of mass of thresholded objects in the two input images and translates the second image so that it better fits to the first image.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationTimelapseRegistration(ClearCLBuffer input, ClearCLBuffer output)";
       description = "<b>translationTimelapseRegistration</b><br><br>Applies 2D translation registration to every pair of t, t+1 slices of a 2D+t image stack.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer output";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXY(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXY</b><br><br>Transpose X and Y axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXZ</b><br><br>Transpose X and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeYZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeYZ</b><br><br>Transpose Y and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.undefinedToZero(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>undefinedToZero</b><br><br>Copies all pixels instead those which are not a number (NaN) or infinity (inf), which are replaced by 0.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfAllPixels(ClearCLBuffer source)";
       description = "<b>varianceOfAllPixels</b><br><br>Determines the variance of all pixels in an image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Variance'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>varianceOfMaskedPixels</b><br><br>Determines the variance in an image, but only in pixels which have non-zero values in another binary mask image. <br><br>The result is put in the results table as new column named 'Masked_variance'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.voronoiLabeling(ClearCLBuffer input, ClearCLImageInterface destination)";
       description = "<b>voronoiLabeling</b><br><br>Takes a binary image, labels connected components and dilates the regions using a octagon shape until they touch. <br><br>The resulting label map is written to the output.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.voronoiOctagon(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>voronoiOctagon</b><br><br>Takes a binary image and dilates the regions using a octagon shape until they touch. <br><br>The pixels where  the regions touched are afterwards returned as binary image which corresponds to the Voronoi diagram.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.watershed(ClearCLBuffer binary_source, ClearCLBuffer destination)";
       description = "<b>watershed</b><br><br>Apply a binary watershed to a binary image and introduces black pixels between objects.<br><br>Parameters:<br>ClearCLBuffer binary_source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.wekaLabelClassifier(ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer destination, String features, String modelfilename)";
       description = "<b>wekaLabelClassifier</b><br><br>Applies a pre-trained CLIJx-Weka model to an image and a corresponding label map. <br><br>Make sure that the handed over feature list is the same used while training the model.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer label_map, ClearCLBuffer destination, String features, String modelfilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeVTKLineListToDisc(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename)";
       description = "<b>writeVTKLineListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and a corresponding touch matrix , sized (n+1)*(n+1), and exports them in VTK format.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeValuesToPositions(ClearCLBuffer positionsAndValues, ClearCLBuffer destination)";
       description = "<b>writeValuesToPositions</b><br><br>Takes an image with three/four rows (2D: height = 3; 3D: height = 4): x, y [, z] and v and target image. <br><br>The value v will be written at position x/y[/z] in the target image.<br><br>Parameters:<br>ClearCLBuffer positionsAndValues, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeXYZPointListToDisc(ClearCLBuffer pointlist, String filename)";
       description = "<b>writeXYZPointListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and exports them in XYZ format.<br><br>Parameters:<br>ClearCLBuffer pointlist, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
        return list;
    }
}
// 482 methods generated.
